// Generated by CoffeeScript 1.6.1

/*
jQuery FlexSlider v2.1
http://www.woothemes.com/flexslider/

Copyright 2012 WooThemes
Free to use under the GPLv2 license.
http://www.gnu.org/licenses/gpl-2.0.html

Contributing author: Tyler Smith (@mbmufffin)
*/


(function() {

  (function($) {
    var custom_setup;
    $.flexslider = function(el, options) {
      var asNav, carousel, eventType, fade, methods, namespace, reverse, slider, touch, vars, vertical;
      slider = $(el);
      vars = $.extend({}, $.flexslider.defaults, options);
      namespace = vars.namespace;
      touch = ("ontouchstart" in window) || window.DocumentTouch && document instanceof DocumentTouch;
      eventType = (touch ? "touchend" : "click");
      vertical = vars.direction === "vertical";
      reverse = vars.reverse;
      carousel = vars.itemWidth > 0;
      fade = true;
      asNav = vars.asNavFor !== "";
      methods = {};
      $.data(el, "flexslider", slider);
      methods = {
        init: function() {
          slider.animating = false;
          slider.currentSlide = vars.startAt;
          slider.animatingTo = slider.currentSlide;
          slider.atEnd = slider.currentSlide === 0 || slider.currentSlide === slider.last;
          slider.containerSelector = vars.selector.substr(0, vars.selector.search(" "));
          slider.slides = $(vars.selector, slider);
          slider.container = $(slider.containerSelector, slider);
          slider.count = slider.slides.length;
          slider.syncExists = $(vars.sync).length > 0;
          if (vars.animation === "slide") {
            vars.animation = "swing";
          }
          slider.prop = (vertical ? "top" : "marginLeft");
          slider.args = {};
          slider.manualPause = false;
          slider.transitions = !vars.video && !fade && vars.useCSS && (function() {
            var i, obj, props;
            obj = document.createElement("div");
            props = ["perspectiveProperty", "WebkitPerspective", "MozPerspective", "OPerspective", "msPerspective"];
            for (i in props) {
              if (obj.style[props[i]] !== undefined) {
                slider.pfx = props[i].replace("Perspective", "").toLowerCase();
                slider.prop = "-" + slider.pfx + "-transform";
                return true;
              }
            }
            return false;
          });
          if (vars.controlsContainer !== "") {
            slider.controlsContainer = $(vars.controlsContainer).length > 0 && $(vars.controlsContainer);
          }
          if (vars.manualControls !== "") {
            slider.manualControls = $(vars.manualControls).length > 0 && $(vars.manualControls);
          }
          if (vars.randomize) {
            slider.slides.sort(function() {
              return Math.round(Math.random()) - 0.5;
            });
            slider.container.empty().append(slider.slides);
          }
          slider.doMath();
          if (asNav) {
            methods.asNav.setup();
          }
          slider.setup("init");
          if (vars.controlNav) {
            methods.controlNav.setup();
          }
          if (vars.directionNav) {
            methods.directionNav.setup();
          }
          if (vars.keyboard && ($(slider.containerSelector).length === 1 || vars.multipleKeyboard)) {
            $(document).bind("keyup", function(event) {
              var keycode, target;
              keycode = event.keyCode;
              if (!slider.animating && (keycode === 39 || keycode === 37)) {
                target = (keycode === 39 ? slider.getTarget("next") : (keycode === 37 ? slider.getTarget("prev") : false));
                return slider.flexAnimate(target, vars.pauseOnAction);
              }
            });
          }
          if (vars.mousewheel) {
            slider.bind("mousewheel", function(event, delta, deltaX, deltaY) {
              var target;
              event.preventDefault();
              target = (delta < 0 ? slider.getTarget("next") : slider.getTarget("prev"));
              return slider.flexAnimate(target, vars.pauseOnAction);
            });
          }
          if (vars.pausePlay) {
            methods.pausePlay.setup();
          }
          if (vars.slideshow) {
            if (vars.pauseOnHover) {
              slider.hover((function() {
                if (!slider.manualPlay && !slider.manualPause) {
                  return slider.pause();
                }
              }), function() {
                if (!slider.manualPause && !slider.manualPlay) {
                  return slider.play();
                }
              });
            }
            if (vars.initDelay > 0) {
              setTimeout(slider.play, vars.initDelay);
            } else {
              slider.play();
            }
          }
          if (touch && vars.touch) {
            methods.touch();
          }
          if (!fade || (fade && vars.smoothHeight)) {
            $(window).bind("resize focus", methods.resize);
          }
          return setTimeout((function() {
            return vars.start(slider);
          }), 200);
        },
        asNav: {
          setup: function() {
            slider.asNav = true;
            slider.animatingTo = Math.floor(slider.currentSlide / slider.move);
            slider.currentItem = slider.currentSlide;
            slider.slides.removeClass(namespace + "active-slide").eq(slider.currentItem).addClass(namespace + "active-slide");
            return slider.slides.click(function(e) {
              var $slide, target;
              e.preventDefault();
              $slide = $(this);
              target = $slide.index();
              if (!$(vars.asNavFor).data("flexslider").animating && !$slide.hasClass("active")) {
                slider.direction = (slider.currentItem < target ? "next" : "prev");
                return slider.flexAnimate(target, vars.pauseOnAction, false, true, true);
              }
            });
          }
        },
        controlNav: {
          setup: function() {
            if (!slider.manualControls) {
              return methods.controlNav.setupPaging();
            } else {
              return methods.controlNav.setupManual();
            }
          },
          setupPaging: function() {
            var i, item, j, type;
            type = (vars.controlNav === "thumbnails" ? "control-thumbs" : "control-paging");
            j = 1;
            item = void 0;
            slider.controlNavScaffold = $("<ol class=\"" + namespace + "control-nav " + namespace + type + "\"></ol>");
            if (slider.pagingCount > 1) {
              i = 0;
              while (i < slider.pagingCount) {
                item = (vars.controlNav === "thumbnails" ? "<img src=\"" + slider.slides.eq(i).attr("data-thumb") + "\"/>" : "<a>" + j + "</a>");
                slider.controlNavScaffold.append("<li>" + item + "</li>");
                j++;
                i++;
              }
            }
            if (slider.controlsContainer) {
              $(slider.controlsContainer).append(slider.controlNavScaffold);
            } else {
              slider.append(slider.controlNavScaffold);
            }
            methods.controlNav.set();
            methods.controlNav.active();
            slider.controlNavScaffold.delegate("a, img", eventType, function(event) {
              var $this, target;
              event.preventDefault();
              $this = $(this);
              target = slider.controlNav.index($this);
              if (!$this.hasClass(namespace + "active")) {
                slider.direction = (target > slider.currentSlide ? "next" : "prev");
                return slider.flexAnimate(target, vars.pauseOnAction);
              }
            });
            if (touch) {
              return slider.controlNavScaffold.delegate("a", "click touchstart", function(event) {
                return event.preventDefault();
              });
            }
          },
          setupManual: function() {
            slider.controlNav = slider.manualControls;
            methods.controlNav.active();
            slider.controlNav.live(eventType, function(event) {
              var $this, target;
              event.preventDefault();
              $this = $(this);
              target = slider.controlNav.index($this);
              if (!$this.hasClass(namespace + "active")) {
                if (target > slider.currentSlide) {
                  slider.direction = "next";
                } else {
                  slider.direction = "prev";
                }
                return slider.flexAnimate(target, vars.pauseOnAction);
              }
            });
            if (touch) {
              return slider.controlNav.live("click touchstart", function(event) {
                return event.preventDefault();
              });
            }
          },
          set: function() {
            var selector;
            selector = (vars.controlNav === "thumbnails" ? "img" : "a");
            return slider.controlNav = $("." + namespace + "control-nav li " + selector, (slider.controlsContainer ? slider.controlsContainer : slider));
          },
          active: function() {
            return slider.controlNav.removeClass(namespace + "active").eq(slider.animatingTo).addClass(namespace + "active");
          },
          update: function(action, pos) {
            if (slider.pagingCount > 1 && action === "add") {
              slider.controlNavScaffold.append($("<li><a>" + slider.count + "</a></li>"));
            } else if (slider.pagingCount === 1) {
              slider.controlNavScaffold.find("li").remove();
            } else {
              slider.controlNav.eq(pos).closest("li").remove();
            }
            methods.controlNav.set();
            if (slider.pagingCount > 1 && slider.pagingCount !== slider.controlNav.length) {
              return slider.update(pos, action);
            } else {
              return methods.controlNav.active();
            }
          }
        },
        directionNav: {
          setup: function() {
            var directionNavScaffold;
            directionNavScaffold = $("<ul class=\"" + namespace + "direction-nav\"><li><a class=\"" + namespace + "prev\" href=\"#\">" + vars.prevText + "</a></li><li><a class=\"" + namespace + "next\" href=\"#\">" + vars.nextText + "</a></li></ul>");
            if (slider.controlsContainer) {
              $(slider.controlsContainer).append(directionNavScaffold);
              slider.directionNav = $("." + namespace + "direction-nav li a", slider.controlsContainer);
            } else {
              slider.append(directionNavScaffold);
              slider.directionNav = $("." + namespace + "direction-nav li a", slider);
            }
            methods.directionNav.update();
            slider.directionNav.bind(eventType, function(event) {
              var target;
              event.preventDefault();
              target = ($(this).hasClass(namespace + "next") ? slider.getTarget("next") : slider.getTarget("prev"));
              return slider.flexAnimate(target, vars.pauseOnAction);
            });
            if (touch) {
              return slider.directionNav.bind("click touchstart", function(event) {
                return event.preventDefault();
              });
            }
          },
          update: function() {
            var disabledClass;
            disabledClass = namespace + "disabled";
            if (slider.pagingCount === 1) {
              return slider.directionNav.addClass(disabledClass);
            } else if (!vars.animationLoop) {
              if (slider.animatingTo === 0) {
                return slider.directionNav.removeClass(disabledClass).filter("." + namespace + "prev").addClass(disabledClass);
              } else if (slider.animatingTo === slider.last) {
                return slider.directionNav.removeClass(disabledClass).filter("." + namespace + "next").addClass(disabledClass);
              } else {
                return slider.directionNav.removeClass(disabledClass);
              }
            } else {
              return slider.directionNav.removeClass(disabledClass);
            }
          }
        },
        pausePlay: {
          setup: function() {
            var pausePlayScaffold;
            pausePlayScaffold = $("<div class=\"" + namespace + "pauseplay\"><a></a></div>");
            if (slider.controlsContainer) {
              slider.controlsContainer.append(pausePlayScaffold);
              slider.pausePlay = $("." + namespace + "pauseplay a", slider.controlsContainer);
            } else {
              slider.append(pausePlayScaffold);
              slider.pausePlay = $("." + namespace + "pauseplay a", slider);
            }
            methods.pausePlay.update((vars.slideshow ? namespace + "pause" : namespace + "play"));
            slider.pausePlay.bind(eventType, function(event) {
              event.preventDefault();
              if ($(this).hasClass(namespace + "pause")) {
                slider.manualPause = true;
                slider.manualPlay = false;
                return slider.pause();
              } else {
                slider.manualPause = false;
                slider.manualPlay = true;
                return slider.play();
              }
            });
            if (touch) {
              return slider.pausePlay.bind("click touchstart", function(event) {
                return event.preventDefault();
              });
            }
          },
          update: function(state) {
            if (state === "play") {
              return slider.pausePlay.removeClass(namespace + "pause").addClass(namespace + "play").text(vars.playText);
            } else {
              return slider.pausePlay.removeClass(namespace + "play").addClass(namespace + "pause").text(vars.pauseText);
            }
          }
        },
        touch: function() {
          var cwidth, dx, offset, onTouchEnd, onTouchMove, onTouchStart, scrolling, startT, startX, startY;
          onTouchStart = function(e) {
            var cwidth, offset, startT, startX, startY;
            if (slider.animating) {
              return e.preventDefault();
            } else if (e.touches.length === 1) {
              slider.pause();
              cwidth = (vertical ? slider.h : slider.w);
              startT = Number(new Date());
              offset = (carousel && reverse && slider.animatingTo === slider.last ? 0 : (carousel && reverse ? slider.limit - (((slider.itemW + vars.itemMargin) * slider.move) * slider.animatingTo) : (carousel && slider.currentSlide === slider.last ? slider.limit : (carousel ? ((slider.itemW + vars.itemMargin) * slider.move) * slider.currentSlide : (reverse ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth)))));
              startX = (vertical ? e.touches[0].pageY : e.touches[0].pageX);
              startY = (vertical ? e.touches[0].pageX : e.touches[0].pageY);
              el.addEventListener("touchmove", onTouchMove, false);
              return el.addEventListener("touchend", onTouchEnd, false);
            }
          };
          onTouchMove = function(e) {
            var dx, scrolling;
            dx = (vertical ? startX - e.touches[0].pageY : startX - e.touches[0].pageX);
            scrolling = (vertical ? Math.abs(dx) < Math.abs(e.touches[0].pageX - startY) : Math.abs(dx) < Math.abs(e.touches[0].pageY - startY));
            if (!scrolling || Number(new Date()) - startT > 500) {
              e.preventDefault();
              if (!fade && slider.transitions) {
                if (!vars.animationLoop) {
                  dx = dx / (slider.currentSlide === 0 && dx < 0 || slider.currentSlide === slider.last && dx > 0 ? Math.abs(dx) / cwidth + 2 : 1);
                }
                return slider.setProps(offset + dx, "setTouch");
              }
            }
          };
          onTouchEnd = function(e) {
            var dx, offset, startX, startY, target, updateDx;
            el.removeEventListener("touchmove", onTouchMove, false);
            if (slider.animatingTo === slider.currentSlide && !scrolling && (dx !== null)) {
              updateDx = (reverse ? -dx : dx);
              target = (updateDx > 0 ? slider.getTarget("next") : slider.getTarget("prev"));
              if (slider.canAdvance(target) && (Number(new Date()) - startT < 550 && Math.abs(updateDx) > 50 || Math.abs(updateDx) > cwidth / 2)) {
                slider.flexAnimate(target, vars.pauseOnAction);
              } else {
                if (!fade) {
                  slider.flexAnimate(slider.currentSlide, vars.pauseOnAction, true);
                }
              }
            }
            el.removeEventListener("touchend", onTouchEnd, false);
            startX = null;
            startY = null;
            dx = null;
            return offset = null;
          };
          startX = void 0;
          startY = void 0;
          offset = void 0;
          cwidth = void 0;
          dx = void 0;
          startT = void 0;
          scrolling = false;
          return el.addEventListener("touchstart", onTouchStart, false);
        },
        resize: function() {
          if (!slider.animating && slider.is(":visible")) {
            if (!carousel) {
              slider.doMath();
            }
            if (fade) {
              return methods.smoothHeight();
            } else if (carousel) {
              slider.slides.width(slider.computedW);
              slider.update(slider.pagingCount);
              return slider.setProps();
            } else if (vertical) {
              slider.viewport.height(slider.h);
              return slider.setProps(slider.h, "setTotal");
            } else {
              if (vars.smoothHeight) {
                methods.smoothHeight();
              }
              slider.newSlides.width(slider.computedW);
              return slider.setProps(slider.computedW, "setTotal");
            }
          }
        },
        smoothHeight: function(dur) {
          if (dur == null) {
            dur = 500;
          }
          console.log(slider.slides.eq(slider.animatingTo).height());
          return $($('.slides')[0]).animate({
            height: slider.slides.eq(slider.animatingTo).height()
          }, dur);
        },
        sync: function(action) {
          var $obj, target;
          $obj = $(vars.sync).data("flexslider");
          target = slider.animatingTo;
          switch (action) {
            case "animate":
              return $obj.flexAnimate(target, vars.pauseOnAction, false, true);
            case "play":
              if (!$obj.playing && !$obj.asNav) {
                return $obj.play();
              }
              break;
            case "pause":
              return $obj.pause();
          }
        }
      };
      slider.flexAnimate = function(target, pause, override, withSync, fromNav) {
        var calcNext, dimension, margin, master, slideString;
        if (asNav && slider.pagingCount === 1) {
          slider.direction = (slider.currentItem < target ? "next" : "prev");
        }
        if (!slider.animating && (slider.canAdvance(target, fromNav) || override) && slider.is(":visible")) {
          if (asNav && withSync) {
            master = $(vars.asNavFor).data("flexslider");
            slider.atEnd = target === 0 || target === slider.count - 1;
            master.flexAnimate(target, true, false, true, fromNav);
            slider.direction = (slider.currentItem < target ? "next" : "prev");
            master.direction = slider.direction;
            if (Math.ceil((target + 1) / slider.visible) - 1 !== slider.currentSlide && target !== 0) {
              slider.currentItem = target;
              slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
              target = Math.floor(target / slider.visible);
            } else {
              slider.currentItem = target;
              slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
              return false;
            }
          }
          slider.animating = true;
          slider.animatingTo = target;
          vars.before(slider);
          if (pause) {
            slider.pause();
          }
          if (slider.syncExists && !fromNav) {
            methods.sync("animate");
          }
          if (vars.controlNav) {
            methods.controlNav.active();
          }
          if (!carousel) {
            slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
          }
          slider.atEnd = target === 0 || target === slider.last;
          if (vars.directionNav) {
            methods.directionNav.update();
          }
          if (target === slider.last) {
            vars.end(slider);
            if (!vars.animationLoop) {
              slider.pause();
            }
          }
          if (!fade) {
            dimension = (vertical ? slider.slides.filter(":first").height() : slider.computedW);
            margin = void 0;
            slideString = void 0;
            calcNext = void 0;
            if (carousel) {
              margin = (vars.itemWidth > slider.w ? vars.itemMargin * 2 : vars.itemMargin);
              calcNext = ((slider.itemW + margin) * slider.move) * slider.animatingTo;
              slideString = (calcNext > slider.limit && slider.visible !== 1 ? slider.limit : calcNext);
            } else if (slider.currentSlide === 0 && target === slider.count - 1 && vars.animationLoop && slider.direction !== "next") {
              slideString = (reverse ? (slider.count + slider.cloneOffset) * dimension : 0);
            } else if (slider.currentSlide === slider.last && target === 0 && vars.animationLoop && slider.direction !== "prev") {
              slideString = (reverse ? 0 : (slider.count + 1) * dimension);
            } else {
              slideString = (reverse ? ((slider.count - 1) - target + slider.cloneOffset) * dimension : (target + slider.cloneOffset) * dimension);
            }
            slider.setProps(slideString, "", vars.animationSpeed);
            if (slider.transitions) {
              if (!vars.animationLoop || !slider.atEnd) {
                slider.animating = false;
                slider.currentSlide = slider.animatingTo;
              }
              slider.container.unbind("webkitTransitionEnd transitionend");
              slider.container.bind("webkitTransitionEnd transitionend", function() {
                return slider.wrapup(dimension);
              });
            } else {
              slider.container.animate(slider.args, vars.animationSpeed, vars.easing, function() {
                return slider.wrapup(dimension);
              });
            }
          } else {
            if (!touch) {
              slider.slides.eq(slider.currentSlide).fadeOut(vars.animationSpeed, vars.easing);
              slider.slides.eq(target).fadeIn(vars.animationSpeed, vars.easing, slider.wrapup);
            } else {
              slider.slides.eq(slider.currentSlide).css({
                opacity: 0,
                zIndex: 1
              });
              slider.slides.eq(target).css({
                opacity: 1,
                zIndex: 2
              });
              slider.slides.unbind("webkitTransitionEnd transitionend");
              slider.slides.eq(slider.currentSlide).bind("webkitTransitionEnd transitionend", function() {
                return vars.after(slider);
              });
              slider.animating = false;
              slider.currentSlide = slider.animatingTo;
            }
          }
          if (vars.smoothHeight) {
            return methods.smoothHeight(vars.animationSpeed);
          }
        }
      };
      slider.wrapup = function(dimension) {
        if (!fade && !carousel) {
          if (slider.currentSlide === 0 && slider.animatingTo === slider.last && vars.animationLoop) {
            slider.setProps(dimension, "jumpEnd");
          } else {
            if (slider.currentSlide === slider.last && slider.animatingTo === 0 && vars.animationLoop) {
              slider.setProps(dimension, "jumpStart");
            }
          }
        }
        slider.animating = false;
        slider.currentSlide = slider.animatingTo;
        return vars.after(slider);
      };
      slider.animateSlides = function() {
        if (!slider.animating) {
          return slider.flexAnimate(slider.getTarget("next"));
        }
      };
      slider.pause = function() {
        clearInterval(slider.animatedSlides);
        slider.playing = false;
        if (vars.pausePlay) {
          methods.pausePlay.update("play");
        }
        if (slider.syncExists) {
          return methods.sync("pause");
        }
      };
      slider.play = function() {
        slider.animatedSlides = setInterval(slider.animateSlides, vars.slideshowSpeed);
        slider.playing = true;
        if (vars.pausePlay) {
          methods.pausePlay.update("pause");
        }
        if (slider.syncExists) {
          return methods.sync("play");
        }
      };
      slider.canAdvance = function(target, fromNav) {
        var last;
        last = (asNav ? slider.pagingCount - 1 : slider.last);
        if (fromNav) {
          return true;
        } else {
          if (asNav && slider.currentItem === slider.count - 1 && target === 0 && slider.direction === "prev") {
            return true;
          } else {
            if (asNav && slider.currentItem === 0 && target === slider.pagingCount - 1 && slider.direction !== "next") {
              return false;
            } else {
              if (target === slider.currentSlide && !asNav) {
                return false;
              } else {
                if (vars.animationLoop) {
                  return true;
                } else {
                  if (slider.atEnd && slider.currentSlide === 0 && target === last && slider.direction !== "next") {
                    return false;
                  } else {
                    if (slider.atEnd && slider.currentSlide === last && target === 0 && slider.direction === "next") {
                      return false;
                    } else {
                      return true;
                    }
                  }
                }
              }
            }
          }
        }
      };
      slider.getTarget = function(dir) {
        slider.direction = dir;
        if (dir === "next") {
          if (slider.currentSlide === slider.last) {
            return 0;
          } else {
            return slider.currentSlide + 1;
          }
        } else {
          if (slider.currentSlide === 0) {
            return slider.last;
          } else {
            return slider.currentSlide - 1;
          }
        }
      };
      slider.setProps = function(pos, special, dur) {
        var target;
        target = (function() {
          var posCalc, posCheck;
          posCheck = (pos ? pos : ((slider.itemW + vars.itemMargin) * slider.move) * slider.animatingTo);
          posCalc = (function() {
            if (carousel) {
              if (special === "setTouch") {
                return pos;
              } else {
                if (reverse && slider.animatingTo === slider.last) {
                  return 0;
                } else {
                  if (reverse) {
                    return slider.limit - (((slider.itemW + vars.itemMargin) * slider.move) * slider.animatingTo);
                  } else {
                    if (slider.animatingTo === slider.last) {
                      return slider.limit;
                    } else {
                      return posCheck;
                    }
                  }
                }
              }
            } else {
              switch (special) {
                case "setTotal":
                  if (reverse) {
                    return ((slider.count - 1) - slider.currentSlide + slider.cloneOffset) * pos;
                  } else {
                    return (slider.currentSlide + slider.cloneOffset) * pos;
                  }
                case "setTouch":
                  if (reverse) {
                    return pos;
                  } else {
                    return pos;
                  }
                case "jumpEnd":
                  if (reverse) {
                    return pos;
                  } else {
                    return slider.count * pos;
                  }
                case "jumpStart":
                  if (reverse) {
                    return slider.count * pos;
                  } else {
                    return pos;
                  }
                default:
                  return pos;
              }
            }
          });
          return (posCalc * -1) + "px";
        });
        if (slider.transitions) {
          target = (vertical ? "translate3d(0," + target + ",0)" : "translate3d(" + target + ",0,0)");
          dur = (dur !== undefined ? (dur / 1000) + "s" : "0s");
          slider.container.css("-" + slider.pfx + "-transition-duration", dur);
        }
        slider.args[slider.prop] = target;
        if (slider.transitions || dur === undefined) {
          return slider.container.css(slider.args);
        }
      };
      slider.setup = function(type) {
        var arr, sliderOffset;
        if (!fade) {
          sliderOffset = void 0;
          arr = void 0;
          if (type === "init") {
            slider.viewport = $("<div class=\"" + namespace + "viewport\"></div>").css({
              overflow: "hidden",
              position: "relative"
            }).appendTo(slider).append(slider.container);
            slider.cloneCount = 0;
            slider.cloneOffset = 0;
            if (reverse) {
              arr = $.makeArray(slider.slides).reverse();
              slider.slides = $(arr);
              slider.container.empty().append(slider.slides);
            }
          }
          if (vars.animationLoop && !carousel) {
            slider.cloneCount = 2;
            slider.cloneOffset = 1;
            if (type !== "init") {
              slider.container.find(".clone").remove();
            }
            slider.container.append(slider.slides.first().clone().addClass("clone")).prepend(slider.slides.last().clone().addClass("clone"));
          }
          slider.newSlides = $(vars.selector, slider);
          sliderOffset = (reverse ? slider.count - 1 - slider.currentSlide + slider.cloneOffset : slider.currentSlide + slider.cloneOffset);
          if (vertical && !carousel) {
            slider.container.height((slider.count + slider.cloneCount) * 200 + "%").css("position", "absolute").width("100%");
            setTimeout((function() {
              slider.newSlides.css({
                display: "block"
              });
              slider.doMath();
              slider.viewport.height(slider.h);
              return slider.setProps(sliderOffset * slider.h, "init");
            }), (type === "init" ? 100 : 0));
          } else {
            slider.container.width((slider.count + slider.cloneCount) * 200 + "%");
            slider.setProps(sliderOffset * slider.computedW, "init");
            setTimeout((function() {
              slider.doMath();
              slider.newSlides.css({
                width: slider.computedW,
                float: "left",
                display: "block"
              });
              if (vars.smoothHeight) {
                return methods.smoothHeight();
              }
            }), (type === "init" ? 100 : 0));
          }
        } else {
          slider.slides.css({
            width: "100%",
            marginRight: "-100%",
            position: "relative",
            float: "left"
          });
          if (type === "init") {
            if (!touch) {
              slider.slides.eq(slider.currentSlide).fadeIn(vars.animationSpeed, vars.easing);
            } else {
              slider.slides.css({
                opacity: 0,
                display: "block",
                webkitTransition: "opacity " + vars.animationSpeed / 1000 + "s ease",
                zIndex: 1
              }).eq(slider.currentSlide).css({
                opacity: 1,
                zIndex: 2
              });
            }
          }
          if (vars.smoothHeight) {
            methods.smoothHeight();
          }
        }
        if (!carousel) {
          return slider.slides.removeClass(namespace + "active-slide").eq(slider.currentSlide).addClass(namespace + "active-slide");
        }
      };
      slider.doMath = function() {
        var maxItems, minItems, slide, slideMargin;
        slide = slider.slides.first();
        slideMargin = vars.itemMargin;
        minItems = vars.minItems;
        maxItems = vars.maxItems;
        slider.w = slider.width();
        slider.h = slide.height();
        slider.boxPadding = slide.outerWidth() - slide.width();
        if (carousel) {
          slider.itemT = vars.itemWidth + slideMargin;
          slider.minW = (minItems ? minItems * slider.itemT : slider.w);
          slider.maxW = (maxItems ? maxItems * slider.itemT : slider.w);
          slider.itemW = (slider.minW > slider.w ? (slider.w - (slideMargin * minItems)) / minItems : (slider.maxW < slider.w ? (slider.w - (slideMargin * maxItems)) / maxItems : (vars.itemWidth > slider.w ? slider.w : vars.itemWidth)));
          slider.visible = Math.floor(slider.w / (slider.itemW + slideMargin));
          slider.move = (vars.move > 0 && vars.move < slider.visible ? vars.move : slider.visible);
          slider.pagingCount = Math.ceil(((slider.count - slider.visible) / slider.move) + 1);
          slider.last = slider.pagingCount - 1;
          slider.limit = (slider.pagingCount === 1 ? 0 : (vars.itemWidth > slider.w ? ((slider.itemW + (slideMargin * 2)) * slider.count) - slider.w - slideMargin : ((slider.itemW + slideMargin) * slider.count) - slider.w - slideMargin));
        } else {
          slider.itemW = slider.w;
          slider.pagingCount = slider.count;
          slider.last = slider.count - 1;
        }
        return slider.computedW = slider.itemW - slider.boxPadding;
      };
      slider.update = function(pos, action) {
        slider.doMath();
        if (!carousel) {
          if (pos < slider.currentSlide) {
            slider.currentSlide += 1;
          } else {
            if (pos <= slider.currentSlide && pos !== 0) {
              slider.currentSlide -= 1;
            }
          }
          slider.animatingTo = slider.currentSlide;
        }
        if (vars.controlNav && !slider.manualControls) {
          if ((action === "add" && !carousel) || slider.pagingCount > slider.controlNav.length) {
            methods.controlNav.update("add");
          } else if ((action === "remove" && !carousel) || slider.pagingCount < slider.controlNav.length) {
            if (carousel && slider.currentSlide > slider.last) {
              slider.currentSlide -= 1;
              slider.animatingTo -= 1;
            }
            methods.controlNav.update("remove", slider.last);
          }
        }
        if (vars.directionNav) {
          return methods.directionNav.update();
        }
      };
      slider.addSlide = function(obj, pos) {
        var $obj;
        $obj = $(obj);
        slider.count += 1;
        slider.last = slider.count - 1;
        if (vertical && reverse) {
          if (pos !== undefined) {
            slider.slides.eq(slider.count - pos).after($obj);
          } else {
            slider.container.prepend($obj);
          }
        } else {
          if (pos !== undefined) {
            slider.slides.eq(pos).before($obj);
          } else {
            slider.container.append($obj);
          }
        }
        slider.update(pos, "add");
        slider.slides = $(vars.selector + ":not(.clone)", slider);
        slider.setup();
        return vars.added(slider);
      };
      slider.removeSlide = function(obj) {
        var pos;
        pos = (isNaN(obj) ? slider.slides.index($(obj)) : obj);
        slider.count -= 1;
        slider.last = slider.count - 1;
        if (isNaN(obj)) {
          $(obj, slider.slides).remove();
        } else {
          if (vertical && reverse) {
            slider.slides.eq(slider.last).remove();
          } else {
            slider.slides.eq(obj).remove();
          }
        }
        slider.doMath();
        slider.update(pos, "remove");
        slider.slides = $(vars.selector + ":not(.clone)", slider);
        slider.setup();
        return vars.removed(slider);
      };
      return methods.init();
    };
    $.flexslider.defaults = {
      namespace: "flex-",
      selector: ".slides > li",
      animation: "slide",
      easing: "swing",
      direction: "horizontal",
      reverse: false,
      animationLoop: true,
      smoothHeight: true,
      startAt: 0,
      slideshow: true,
      slideshowSpeed: 7000,
      animationSpeed: 600,
      initDelay: 0,
      randomize: false,
      pauseOnAction: true,
      pauseOnHover: false,
      useCSS: true,
      touch: true,
      video: false,
      controlNav: true,
      directionNav: true,
      prevText: "Previous",
      nextText: "Next",
      keyboard: true,
      multipleKeyboard: false,
      mousewheel: false,
      pausePlay: false,
      pauseText: "Pause",
      playText: "Play",
      controlsContainer: "",
      manualControls: "",
      sync: "",
      asNavFor: "",
      itemWidth: 0,
      itemMargin: 0,
      minItems: 0,
      maxItems: 0,
      move: 0,
      start: function(slider) {
        return custom_setup(slider);
      },
      before: function() {},
      after: function(slider) {
        return custom_setup(slider);
      },
      end: function() {},
      added: function() {},
      removed: function() {}
    };
    custom_setup = function(slider) {
      var html, i, tags;
      $("#image_title").html($(slider.slides[slider.currentSlide]).attr("data-title") || '&nbsp;');
      tags = JSON.parse($(slider.slides[slider.currentSlide]).attr("data-tags"));
      html = "";
      i = tags.length - 1;
      while (i >= 0) {
        html += "<span>" + tags[i] + "</span>";
        i--;
      }
      return $("#image_tags").html(html);
    };
    return $.fn.flexslider = function(options) {
      var $slider;
      if (options === undefined) {
        options = {};
      }
      if (typeof options === "object") {
        return this.each(function() {
          var $slides, $this, selector;
          $this = $(this);
          selector = (options.selector ? options.selector : ".slides > li");
          $slides = $this.find(selector);
          if ($slides.length === 1) {
            $slides.fadeIn(400);
            if (options.start) {
              return options.start($this);
            }
          } else {
            if ($this.data("flexslider") === undefined) {
              return new $.flexslider(this, options);
            }
          }
        });
      } else {
        $slider = $(this).data("flexslider");
        switch (options) {
          case "play":
            return $slider.play();
          case "pause":
            return $slider.pause();
          case "next":
            return $slider.flexAnimate($slider.getTarget("next"), true);
          case "prev":
          case "previous":
            return $slider.flexAnimate($slider.getTarget("prev"), true);
          default:
            if (typeof options === "number") {
              return $slider.flexAnimate(options, true);
            }
        }
      }
    };
  })(jQuery);

}).call(this);
